-- Auto Updater from https://github.com/hexarobi/stand-lua-auto-updater
local status, auto_updater = pcall(require, "auto-updater")
if not status then
    local auto_update_complete = nil util.toast("Installing auto-updater...", TOAST_ALL)
    async_http.init("raw.githubusercontent.com", "/hexarobi/stand-lua-auto-updater/main/auto-updater.lua",
        function(result, headers, status_code)
            local function parse_auto_update_result(result, headers, status_code)
                local error_prefix = "Error downloading auto-updater: "
                if status_code ~= 200 then util.toast(error_prefix..status_code, TOAST_ALL) return false end
                if not result or result == "" then util.toast(error_prefix.."Found empty file.", TOAST_ALL) return false end
                filesystem.mkdir(filesystem.scripts_dir() .. "lib")
                local file = io.open(filesystem.scripts_dir() .. "lib\\auto-updater.lua", "wb")
                if file == nil then util.toast(error_prefix.."Could not open file for writing.", TOAST_ALL) return false end
                file:write(result) file:close() util.toast("Successfully installed auto-updater lib", TOAST_ALL) return true
            end
            auto_update_complete = parse_auto_update_result(result, headers, status_code)
        end, function() util.toast("Error downloading auto-updater lib. Update failed to download.", TOAST_ALL) end)
    async_http.dispatch() local i = 1 while (auto_update_complete == nil and i < 40) do util.yield(250) i = i + 1 end
    if auto_update_complete == nil then error("Error downloading auto-updater lib. HTTP Request timeout") end
    auto_updater = require("auto-updater")
end
if auto_updater == true then error("Invalid auto-updater lib. Please delete your Stand/Lua Scripts/lib/auto-updater.lua and try again") end


auto_updater.run_auto_update({
    source_url="https://raw.githubusercontent.com/Kizzer2003/GrabHost/main/grabhost.pluto",
    script_relpath="lib/auto-updater.lua",
    check_interval=10,
})


script_version = 1.04


util.keep_running()
util.ensure_package_is_installed("natives-1681379138")
util.require_natives(1681379138)

if not SCRIPT_SILENT_START then
    util.toast("GrabHost Version: "..script_version)
end

local my_root = menu.my_root()

function hostspoofing(pid)
    players.add_command_hook(function(pid, root)
        local host = players.get_host_queue_position(pid)
        if host == 0 or host == "N/A" then
            local player = players.get_name(pid)
            util.yield(10000)
            local me = players.get_connect_port(pid)
            if not me == "N/A" or me == 0 then
                util.yield()
            else
                util.yield(800)
                menu.trigger_commands("kick" .. player)
                util.yield(4300)
                local uhost = players.get_connect_port(pid)
                -- REQUIRES ACTUAL TESTING
                if uhost == "N/A" or uhost == 0 then
                    util.toast("If everything went to plan, you are now host :D")
                    util.yield()
                else
                    util.toast("Something went wrong, bailing you from the session. Try joining another")
                    util.yield(500)
                    -- MAKE A CHECK TO SEE IF YOU ARE IN A SESSION BY YOURSELF (SUCH AS FINDING THE ID AND NAME OF ALL PLAYERS AND THEN MAKING AN IF STATEMENT TO CHECK TO SEE IF THERE ARE MORE PLAYERS
                    -- THAN ONE AND IF SO, EXECUTE BE ALONE
                    menu.trigger_commands("bealone")
                    util.yield(6000)
                    menu.trigger_commands("go public")
                    util.toast("Joining Public Session")
                end
            end
        end
    end)
end

menu.toggle(my_root, "Easy Host", {'ehost'}, "Works with Stand Basic and Regular. Enables Host Token Spoofing, loads you into a session then kicks the host", function(toggled)
    if toggled then
        --local hostref = menu.ref_by_command_name("hosttokenspoofing")
        menu.trigger_commands("hosttokenspoofing on")
        menu.trigger_commands("spoofedhosttoken 0000000000000000")
        -- Old version that did not rejoin util.toast("You will need to rejoin or switch sessions for this to apply")
        -- Go solo session because it loads quickly and bypasses the need for a user needing to join a previous
        -- session for this to work previously - Could be improved upon but is suitable for now
        local sessionstart = util.is_session_started(false) 
        if not sessionstart then 
            menu.trigger_commands("go solo")
            util.toast("Joining Online")
            util.yield(10000)
            hostspoofing()
            util.yield(5700)
            menu.trigger_commands("go public")
        elseif sessionstart == true then
            menu.trigger_commands("bealone")
            util.toast("Leaving Session...")
            util.yield(4000)
            util.toast("Rejoining Previous Session...")
            menu.trigger_commands("rejoin")
            util.yield(7200)
            hostspoofing()
        end
            --[[menu.trigger_commands("rejoin")
            util.toast("Rejoining...")
            util.yield(1900)
            local noprev = util.is_session_started(true)
            if noprev == true then
                hostspoofing()
            elseif noprev == false then
                menu.trigger_commands("go inviteonly")
                util.toast("There is no previous session to rejoin. Sending you to an invite only session and then rejoin the old session.")
                util.yield(9000)
                menu.trigger_commands("rejoin")
                util.toast("Joining Previous Session...")
                util.yield(7000)
                local trans = util.is_session_transition_active(true)
                if trans then
                    hosttokenspoofing()
                else
                    menu.trigger_commands("go public")
                    util.toast("No previous session found. Sending you to a public session")
                    hosttokenspoofing()
                end
            end--]]
            --[[players.add_command_hook(function(pid, root)
                local host = players.get_host_queue_position(pid)
                if host == 0 or host == "N/A" then
                    local player = players.get_name(pid)
                    util.yield(15000)
                    local me = players.get_connect_port(pid)
                    if not me == "N/A" or me == 0 then
                        util.yield()
                    else
                        menu.trigger_commands("kick" .. player)
                        util.yield(3700)
                        local uhost = players.get_connect_port(pid)
                        -- REQUIRES ACTUAL TESTING
                        if uhost == "N/A" or uhost == 0 then
                            util.toast("If everything went to plan, you are now host :D")
                            util.yield()
                        else
                            util.toast("Something went wrong, bailing you from the session. Try joining another")
                            menu.trigger_commands("go inviteonly")
                        end
                    end
                end
            end)--]]
      
    else
        menu.trigger_commands("hosttokenspoofing off")
        util.toast("Host Token Spoofing is now off! Your token value is saved at the best value possible.")
    end
end)



local misc = menu.list(my_root, "Misc", {''}, "")
misc:divider("Version: 1.02")
misc:hyperlink("My Github Repository","https://github.com/Kizzer2003/GrabHost")
misc:action("Check for Update", {}, "The script will automatically check for updates at most daily, but you can manually check using this option anytime.", function()
    auto_update_config.check_interval = 0
    util.toast("Checking for updates")
    auto_updater.run_auto_update(auto_update_config)
end)
