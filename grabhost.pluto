-- Auto Updater from https://github.com/hexarobi/stand-lua-auto-updater
local status, auto_updater = pcall(require, "auto-updater")
if not status then
    local auto_update_complete = nil util.toast("Installing auto-updater...", TOAST_ALL)
    async_http.init("raw.githubusercontent.com", "/hexarobi/stand-lua-auto-updater/main/auto-updater.lua",
        function(result, headers, status_code)
            local function parse_auto_update_result(result, headers, status_code)
                local error_prefix = "Error downloading auto-updater: "
                if status_code ~= 200 then util.toast(error_prefix..status_code, TOAST_ALL) return false end
                if not result or result == "" then util.toast(error_prefix.."Found empty file.", TOAST_ALL) return false end
                filesystem.mkdir(filesystem.scripts_dir() .. "lib")
                local file = io.open(filesystem.scripts_dir() .. "lib\\auto-updater.lua", "wb")
                if file == nil then util.toast(error_prefix.."Could not open file for writing.", TOAST_ALL) return false end
                file:write(result) file:close() util.toast("Successfully installed auto-updater lib", TOAST_ALL) return true
            end
            auto_update_complete = parse_auto_update_result(result, headers, status_code)
        end, function() util.toast("Error downloading auto-updater lib. Update failed to download.", TOAST_ALL) end)
    async_http.dispatch() local i = 1 while (auto_update_complete == nil and i < 40) do util.yield(250) i = i + 1 end
    if auto_update_complete == nil then error("Error downloading auto-updater lib. HTTP Request timeout") end
    auto_updater = require("auto-updater")
end
if auto_updater == true then error("Invalid auto-updater lib. Please delete your Stand/Lua Scripts/lib/auto-updater.lua and try again") end


local auto_updater_config = {
    source_url="https://raw.githubusercontent.com/Kizzer2003/GrabHost/main/grabhost.pluto",
    script_relpath=SCRIPT_RELPATH,
    verify_file_begins_with=nil,
    check_interval=86400,
}

auto_updater.run_auto_update(auto_updater_config)

script_version = "2.5"


util.keep_running()
util.require_natives(1681379138)

if not SCRIPT_SILENT_START then
    util.toast("GrabHost Version: "..script_version)
end

local my_root = menu.my_root()

players.add_command_hook(function(pid, root)
    if pid != players.user() and (players.get_name(pid) == "LordMcNuggie" or players.get_name(pid) == "__Kizzer__") then
        players.add_detection(pid, "GrabHost Developer", TOAST_DEFAULT, 1)
    end
end)


-- Removed the hostspoofing function and temporarily replaced it with this
-- This function will be used for the reworked version that also includes more functions
-- Util.toast() does not work in the easy host feature but that may be due to how it currently
-- functions -- Changes will be made to it in the next version anyway so the lack of text is
-- sufficient enough for now as a temp fix
function kick()
    local playpos = players.get_host_queue_position(players.user())
    local player = players.user()
    local host = players.get_host()
    local hostname = players.get_name(host)
    if util.is_session_started() then
        if not util.is_session_transition_active() then
            if playpos == 1 then
                util.toast("Kicking the host...")
                util.yield(2500)
                menu.trigger_commands("kick"..hostname)
                util.yield(4000)
                local newhost = players.get_host()
                -- local newhost = players.get_host_queue_position(players.user())
                if newhost == players.user() then
                -- newhost == 0 or newhost == "N/A" then
                    util.yield(700)
                    util.toast("You are now the host")
                else
                    util.toast("Something bad happened, host could not be kicked. Bailing the session")
                    menu.trigger_commands("bealone")
                end
            end
        end
        if playpos >= 2 then
            util.toast("Not kicking the host as you are not the next host. Activate host token spoofing or easy host to become host")
            return
        end
    end

end

local easyhost = menu.toggle(my_root, "Easy Host", {'ehost'}, "Works with Stand Basic and Regular. Enables Host Token Spoofing, loads you into a session then kicks the host", function(toggled)
    if toggled then
        menu.trigger_commands("hosttokenspoofing on")
        menu.trigger_commands("spoofedhosttoken 0000000000000000")
        local sessionstart = util.is_session_started(false) 
        if not sessionstart then 
            menu.trigger_commands("go public")
            util.toast("Joining Online")
        elseif sessionstart == true then
            menu.trigger_commands("bealone")
            util.toast("Leaving Session...")
            util.yield(4000)
            util.toast("Rejoining Previous Session...")
            menu.trigger_commands("rejoin")
        end
        kick()

    else
        menu.trigger_commands("hosttokenspoofing off")
        util.toast("Host Token Spoofing is now off! Make sure you change sessions to apply remove your spoofed host token")
    end
end)


menu.toggle_loop(my_root, "Kick Host When Next In Queue", {''}, "Similar to the built in Ultimate feature, this auto kicks the host when you are next in the queue. MAKE SURE YOU HAVE HOST TOKEN SPOOFING ENABLED FOR THIS TO ACTUALLY KICK THE HOST", function()
    kick()
    end, function()
        util.toast("Auto Kicking Is Now Off")
    
end)

local misc = menu.list(my_root, "Misc", {''}, "")
misc:divider("Version: 2.5")
misc:hyperlink("My Github Repository - Changelog is also provided here and you can manually update the script","https://github.com/Kizzer2003/GrabHost")
misc:action("Update Script", {''}, "The script should update automatically but if it does not, this should update it", function()
    auto_updater_config.check_interval = 0
    util.toast("Checking for updates")
    auto_updater.run_auto_update(auto_updater_config)
end)
